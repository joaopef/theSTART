{"config":{"lang":["en","pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"~$ whoami","text":"<p>Jo\u00e3o \u2013 tech enthusiast, breaker of things, occasional fixer </p> <p>Hey, my name is Jo\u00e3o and I\u2019m a tech enthusiast who loves breaking things, not always fixing them, and sometimes learning along the way. I\u2019m currently a student, so between classes and life, I try to spend time diving into cybersecurity, playing CTFs, pwning machines on TryHackMe and HackTheBox, and tinkering with electronics.  </p> <p>This repo is basically my personal brain dump, where I document my projects, things I\u2019m learning, and random experiments.  </p> <p>\ud83d\udea7 Still a work in progress... updates will come whenever I get around to it! \ud83d\ude06  </p> <p>Dark mode next to the search bar :)</p>"},{"location":"#find-me-here","title":"\ud83d\udcec Find me here:","text":""},{"location":"Air%20Monitor/","title":"Sensor de Monitoriza\u00e7\u00e3o do Ar para Casa","text":"<p>Uma das poucas li\u00e7\u00f5es positivas que a pandemia de Covid-19 nos deixou foi a perce\u00e7\u00e3o de que existem riscos invis\u00edveis \u00e0 nossa sa\u00fade dentro dos espa\u00e7os fechados. Muitos poluentes e subst\u00e2ncias contaminantes est\u00e3o presentes nos ambientes interiores sem que os nossos sentidos \u2013 como o olfato, o paladar ou a vis\u00e3o \u2013 nos possam alertar para o perigo.</p> <p>\u00c9 aqui que entram os monitores de qualidade do ar interior (IAQ). Estes dispositivos detetam a presen\u00e7a de poluentes e fornecem dados objetivos sobre os n\u00edveis de contamina\u00e7\u00e3o, permitindo-nos agir antes que se tornem um risco real. Quanto mais informa\u00e7\u00e3o tivermos, mais conscientes e eficazes ser\u00e3o as nossas decis\u00f5es para manter um ambiente saud\u00e1vel e seguro.</p>"},{"location":"Air%20Monitor/#parametros-mais-importantes","title":"Par\u00e2metros Mais Importantes","text":"<p>H\u00e1 v\u00e1rios par\u00e2metros que conv\u00e9m medir, mas os principais s\u00e3o:</p>"},{"location":"Air%20Monitor/#temperatura-e-humidade","title":"Temperatura e Humidade","text":"<p>Conhecer os valores de temperatura e humidade de um espa\u00e7o ajuda a identificar condi\u00e7\u00f5es que favorecem o crescimento de bact\u00e9rias e bolor. Ambientes muito h\u00famidos aumentam esse risco. Alguns dispositivos tamb\u00e9m calculam o ponto de orvalho \u2013 a temperatura na qual o ar j\u00e1 n\u00e3o consegue reter mais vapor de \u00e1gua, levando \u00e0 condensa\u00e7\u00e3o.</p>"},{"location":"Air%20Monitor/#co2-dioxido-de-carbono","title":"CO2 (Di\u00f3xido de Carbono)","text":"<p>O CO2 \u00e9 um composto qu\u00edmico que os humanos libertam ao respirar. N\u00edveis elevados podem causar fadiga, falta de concentra\u00e7\u00e3o e redu\u00e7\u00e3o da produtividade. Monitorizar os n\u00edveis de CO2 permite avaliar a qualidade da ventila\u00e7\u00e3o de um espa\u00e7o e saber quando \u00e9 necess\u00e1rio arejar.</p>"},{"location":"Air%20Monitor/#particulate-matter-pm","title":"Particulate Matter (PM)","text":"<p>As part\u00edculas em suspens\u00e3o (PM) s\u00e3o uma mistura de part\u00edculas s\u00f3lidas e l\u00edquidas t\u00e3o pequenas que podem ser inaladas, afetando a sa\u00fade respirat\u00f3ria. S\u00e3o originadas por poeira, fumo, polui\u00e7\u00e3o, entre outros.  </p> <ul> <li>PM10 \u2013 Part\u00edculas com di\u00e2metro inferior a 10 micr\u00f3metros.  </li> <li>PM2.5 \u2013 Part\u00edculas com di\u00e2metro inferior a 2.5 micr\u00f3metros, consideradas as mais perigosas para a sa\u00fade.  </li> </ul> <p>Para compara\u00e7\u00e3o, um fio de cabelo humano tem aproximadamente 70 micr\u00f3metros de di\u00e2metro.</p>"},{"location":"Air%20Monitor/#hardware","title":"Hardware","text":"<ul> <li> <p>ESP32C6 - Dispositivo central respons\u00e1vel pela recolha e transmiss\u00e3o de dados via WiFi 6 e Bluetooth 5, garantindo uma comunica\u00e7\u00e3o eficiente com os sensores.  </p> </li> <li> <p>SHT41 - Sensor de temperatura e humidade com maior precis\u00e3o do que os comuns DHT11 e DHT22. Comunica via I2C e permite medi\u00e7\u00f5es de temperatura entre -40\u00b0C e 125\u00b0C e de humidade entre 0% e 100%.  </p> </li> <li> <p>Senseair S8 - Sensor de CO2 do tipo NDIR (Non-Dispersive Infrared), garantindo medi\u00e7\u00f5es mais est\u00e1veis e precisas do que sensores MOX. Mede concentra\u00e7\u00f5es de CO2 entre 400 e 5000 ppm, com uma precis\u00e3o de \u00b140 ppm + 3% da leitura. Comunica via UART.  </p> </li> <li> <p>Plantower PMS2.5 - Sensor de part\u00edculas em suspens\u00e3o (PM), capaz de medir PM1.0, PM2.5 e PM10. Permite identificar part\u00edculas com di\u00e2metros m\u00ednimos de 0.3 \u00b5m, sendo \u00fatil para monitorizar poeira, fumo e polui\u00e7\u00e3o urbana. Comunica via UART.  </p> </li> </ul>"},{"location":"Air%20Monitor/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<p>Para n\u00e3o seguir o caminho tradicional com Arduino IDE e experimentar algo novo, decidi utilizar ESP IDF. \u00c9 uma op\u00e7\u00e3o mais flex\u00edvel, permitindo testar rapidamente os sensores sem complica\u00e7\u00e3o.  </p>"},{"location":"Air%20Monitor/#configurar-o-esp32-c6","title":"Configurar o ESP32-C6","text":"<p>O ESP32-C6 vem sem ESP IDF instalado, ent\u00e3o \u00e9 necess\u00e1rio flashar o firmware antes de come\u00e7ar.  </p>"},{"location":"Air%20Monitor/#1-instalar-o-esptool","title":"1. Instalar o esptool","text":"<p>Antes de tudo, precisamos do esptool, que serve para interagir com microcontroladores ESP. Como j\u00e1 tenho Python instalado, basta abrir o cmd e executar: <code>pip install esptool</code></p>"},{"location":"Air%20Monitor/#2-ligar-o-esp32-c6-ao-pc","title":"2. Ligar o ESP32-C6 ao PC","text":"<p>A parte mais complicada... conectar o ESP32-C6 ao PC usando um cabo USB-C para USB-A \ud83d\ude06.  </p>"},{"location":"Air%20Monitor/#3-instalar-os-drivers-usb-to-uart","title":"3. Instalar os drivers USB to UART","text":"<p>Para que o ESP32-C6 seja reconhecido corretamente, precisamos dos USB to UART Bridge VCP Drivers.  </p> <ul> <li>O download pode ser feito diretamente em Silicon Labs.  </li> <li>Ap\u00f3s o download, extrair os ficheiros e localizar <code>silabser.inf</code>.  </li> <li>Clicar com o bot\u00e3o direito e selecionar Instalar.  </li> </ul> <p>Agora, no Device Manager, o dispositivo deve aparecer como Silicon Labs CP210x USB to UART Bridge (COMx). Tomar nota do n\u00famero da porta COM atribu\u00edda (no meu caso, COM3).  </p>"},{"location":"Air%20Monitor/#4-limpar-a-flash-do-esp32-c6","title":"4. Limpar a flash do ESP32-C6","text":"<p>Antes de instalar o firmware, conv\u00e9m limpar a mem\u00f3ria do ESP para evitar problemas. No terminal, correr:  <code>python -m esptool --port COM3 erase_flash</code></p> <p>Se tudo correr bem, deve aparecer a mensagem: Chip erase completed successfully.</p>"},{"location":"Air%20Monitor/#5-instalar-o-esp-idf","title":"5. Instalar o ESP-IDF","text":"<p>Podemos fazer download da vers\u00e3o mais recente para Windows do ESP-IDF para o ESP32-C6 neste link.  </p> <p>Durante o processo de instala\u00e7\u00e3o, selecionei a op\u00e7\u00e3o de criar atalhos no ambiente de trabalho, facilitando o acesso ao ESP-IDF Command Prompt e ao IDE.  </p>"},{"location":"Air%20Monitor/#6-testar-com-hello-world","title":"6. Testar com Hello World","text":"<p>Depois de instalado, podemos verificar se tudo est\u00e1 a funcionar corretamente com um pequeno teste:  </p> <ul> <li>Abir o ESP-IDF CMD e navegar at\u00e9 ao exemplo j\u00e1 inclu\u00eddo de Hello World: <code>cd %IDF_PATH%\\examples\\get-started\\hello_world</code></li> <li>Definir o target para a nossa board ESP32-C6: <code>idf.py set-target esp32c6</code></li> <li>Fazer build do firmware: <code>idf.py build</code></li> <li>Flashar o firmware para a board: <code>idf.py -p COM3 flash</code></li> <li>Confirmar que est\u00e1 a imprimir Hello World, visualizando o output do serial monitor: <code>idf.py -p COM3 monitor</code></li> </ul>"},{"location":"Air%20Monitor/#ligacoes","title":"Liga\u00e7\u00f5es","text":"<p>Como refer\u00eancia para as liga\u00e7\u00f5es, utilizo esta imagem da board que estou a usar: </p> <p>Conforme mencionado na sec\u00e7\u00e3o de hardware, os sensores comunicam da seguinte forma: - Senseair S8 e Plantower PMS2.5 \u2192 UART - SHT41 \u2192 I2C  </p>"},{"location":"Air%20Monitor/#configuracao-de-dados","title":"Configura\u00e7\u00e3o de Dados","text":"<p>Para armazenar e visualizar os dados dos sensores, utilizei o InfluxDB, o Mosquitto MQTT Broker e o Telegraf para integrar os servi\u00e7os.  </p>"},{"location":"Air%20Monitor/#1-instalar-e-configurar-o-influxdb","title":"1. Instalar e configurar o InfluxDB","text":"<ol> <li>Fazer download da vers\u00e3o mais recente do InfluxDB v2 no site oficial.  </li> <li>Abrir o PowerShell em modo Administrador e navegar at\u00e9 a pasta de Downloads.  </li> <li>Executar o seguinte comando para extrair os ficheiros:  </li> </ol> <pre><code>Expand-Archive .\\influxdb2-2.7.11-windows.zip -DestinationPath 'C:\\Program Files\\InfluxData'\n</code></pre> <ol> <li>Clicar com o bot\u00e3o direito no .exe, copiar o caminho completo e abrir o CMD.  </li> <li>Colar o caminho copiado e pressionar Enter.  </li> </ol> <p>O WebUI do InfluxDB deve abrir em <code>http://localhost:8086</code>. Criar uma conta e seguir as instru\u00e7\u00f5es iniciais.  </p>"},{"location":"Air%20Monitor/#2-instalar-e-configurar-o-mosquitto-mqtt-broker","title":"2. Instalar e configurar o Mosquitto MQTT Broker","text":"<ol> <li>Fazer download do Mosquitto no site oficial.  </li> <li>Ap\u00f3s a instala\u00e7\u00e3o, abrir o CMD, navegar at\u00e9 a pasta de instala\u00e7\u00e3o e iniciar o servi\u00e7o com:  <code>mosquitto</code></li> </ol>"},{"location":"Air%20Monitor/#testar-a-comunicacao-mqtt","title":"Testar a comunica\u00e7\u00e3o MQTT","text":"<p>Abrir dois CMDs:  </p> <ul> <li>CMD 1 (para subscrever a um t\u00f3pico):  </li> </ul> <pre><code>\"C:\\Program Files\\mosquitto\\mosquitto_sub.exe\" -h 127.0.0.1 -t test/topic\n</code></pre> <ul> <li>CMD 2 (para publicar uma mensagem no t\u00f3pico):  </li> </ul> <pre><code>\"C:\\Program Files\\mosquitto\\mosquitto_pub.exe\" -h 127.0.0.1 -t test/topic -m \"Hello from Mosquitto\"\n</code></pre> <p>Se a mensagem \"Hello from Mosquitto\" aparecer no primeiro terminal, a comunica\u00e7\u00e3o MQTT est\u00e1 a funcionar corretamente.  </p> <p>Agora, precisamos de conectar o Mosquitto ao InfluxDB atrav\u00e9s do Telegraf e do MQTT Consumer.  </p>"},{"location":"Air%20Monitor/#3-instalar-e-configurar-o-telegraf","title":"3. Instalar e configurar o Telegraf","text":"<ol> <li>Fazer download do Telegraf no site oficial.  </li> <li>No PowerShell (modo Administrador), executar:  </li> </ol> <pre><code>wget https://dl.influxdata.com/telegraf/releases/telegraf-1.34.0_windows_amd64.zip -UseBasicParsing -OutFile telegraf-1.34.0_windows_amd64.zip\n</code></pre> <ol> <li>Ap\u00f3s o download, extrair os ficheiros:  </li> </ol> <pre><code>Expand-Archive .\\telegraf-1.34.0_windows_amd64.zip -DestinationPath 'C:\\Program Files\\InfluxData\\telegraf'\n</code></pre>"},{"location":"Air%20Monitor/#4-configurar-o-telegraf-para-consumir-mqtt","title":"4. Configurar o Telegraf para consumir MQTT","text":"<ol> <li>No WebUI do InfluxDB, criar um Telegraf Configuration File:  </li> <li>Escolher o bucket Sensores.  </li> <li>Selecionar o plugin MQTT Consumer na Plugin Library.  </li> <li>Adicionar os seguintes inputs:  </li> </ol> <pre><code>[[inputs.mqtt_consumer]] servers = [\"tcp://127.0.0.1:1883\"] topics = [ \"sensores/sht41/temperature\", \"sensores/sht41/humidity\", \"sensores/gcja5/pm1\", \"sensores/gcja5/pm2.5\", \"sensores/gcja5/pm10\", \"sensores/sensair_s8/co2\" ] data_format = \"influx\"\n</code></pre> <ol> <li>Adicionar o Token de Autentica\u00e7\u00e3o conforme indicado no WebUI.  </li> </ol>"},{"location":"Air%20Monitor/#5-testar-a-configuracao","title":"5. Testar a configura\u00e7\u00e3o","text":"<p>Abrir dois CMDs:  </p> <ul> <li>CMD 1 (para monitorizar os dados recebidos pelo Telegraf):  </li> </ul> <pre><code>telegraf --config http://localhost:8086/api/v2/telegrafs/0e96aec27fc2a000 --debug\n</code></pre> <ul> <li>CMD 2 (para enviar dados de teste via Mosquitto):  </li> </ul> <pre><code>mosquitto_pub -h 127.0.0.1 -t sensores/sht41/temperature -m \"temperature,location=office value=25.3\"\n</code></pre> <p>Se tudo estiver configurado corretamente, o terminal deve exibir a mensagem de sucesso:  </p> <p>[outputs.influxdb_v2] Wrote batch of 1 metrics in 5.0302ms</p>"},{"location":"Air%20Monitor/#6-visualizar-os-dados-no-influxdb","title":"6. Visualizar os dados no InfluxDB","text":"<ol> <li>Aceder ao WebUI do InfluxDB.  </li> <li>Ir a Data Explorer e abrir o Script Editor.  </li> <li>Executar a seguinte query para visualizar os dados:  </li> </ol> <pre><code>from(bucket: \"Sensores\") |&gt; range(start: -1h) |&gt; filter(fn: (r) =&gt; r._measurement == \"temperature\" or r._measurement == \"humidity\")\n</code></pre> <p>Os valores dos sensores devem aparecer no gr\u00e1fico.</p> <p>\ud83d\udea7 Work in Progress \ud83d\udea7</p>"},{"location":"HOW_IT_WORKS/","title":"Pwnagotchi: How it Works","text":"<p>Pwnagotchi is an A2C-based (\u201cAI\u201d) powered by bettercap that learns from its surrounding WiFi environment in order to maximize the crackable WPA key material it captures (either through passive sniffing or by performing deauthentication and association attacks). This material is collected on disk as PCAP files containing any form of crackable handshake supported by hashcat, including full and half WPA handshakes as well as PMKIDs.</p>"},{"location":"HOW_IT_WORKS/#key-terms","title":"Key Terms","text":"<ul> <li> <p>A2C: This stands for Advantage Actor-Critic, which is an algorithm used in reinforcement learning. It combines both the actor (which decides what action to take) and the critic (which evaluates the action taken). A2C is used in the Pwnagotchi\u2019s AI to help it adapt and improve its actions over time, based on the feedback from its environment.</p> </li> <li> <p>Bettercap: This is a tool used for network attacks and packet manipulation, which allows Pwnagotchi to interact with wireless networks and gather data for Wi-Fi cracking.</p> </li> <li> <p>Deauthentication and Association Attacks: These are types of attacks used to disrupt the connection between a device and a Wi-Fi network. Deauthentication causes a device to disconnect from a network, and Association attacks allow Pwnagotchi to intercept the process and capture handshakes.</p> </li> <li> <p>PCAP files: These are files used to store network traffic data, specifically Wi-Fi handshakes (critical for cracking WPA keys). Pwnagotchi collects these for later hashcat processing.</p> </li> <li> <p>Handshakes: These are pieces of data exchanged between a Wi-Fi client and an access point during the connection process. They are essential for cracking WPA keys.</p> </li> <li> <p>Hashcat: A password cracking tool used to crack encrypted data like WPA handshakes. It can use various techniques to try and break the encryption.</p> </li> <li> <p>PMKID: This is a specific type of data that can also be used to crack WPA encryption. PMKID is a Pre-Shared Key identifier used in WPA2 networks and is often targeted in Wi-Fi hacking.</p> </li> </ul>"},{"location":"HOW_IT_WORKS/#how-does-pwnagotchi-work","title":"How does Pwnagotchi work?","text":"<p>Instead of merely playing Super Mario or Atari games like most reinforcement learning-based AI (yawn), Pwnagotchi tunes its own parameters over time to get better at pwning WiFi things in the environments you expose it to.</p> <p>To be more precise, Pwnagotchi is using an LSTM with an MLP feature extractor as its policy network for the A2C agent. If you\u2019re unfamiliar with A2C, here is a very good introductory explanation (in comic form!) of the basic principles behind how Pwnagotchi learns. Be sure to check out the Usage doc for more pragmatic details of how to help your Pwnagotchi learn as quickly as possible.</p> <ul> <li> <p>LSTM (Long Short-Term Memory): A type of recurrent neural network (RNN) used in machine learning. LSTM networks are great for learning from sequences of data (like Wi-Fi networks over time) because they can \"remember\" past events and adjust their actions accordingly.</p> </li> <li> <p>MLP (Multilayer Perceptron): A type of neural network used for feature extraction, which helps the system analyze and process data more effectively. Pwnagotchi uses it to process information from the Wi-Fi environment and make better decisions.</p> </li> </ul> <p>Unlike the usual reinforcement learning simulations, Pwnagotchi actually learns at a human timescale because it is interacting with a real-world environment instead of a well-defined virtual environment (like playing Super Mario). Time for a Pwnagotchi is measured in epochs; a single epoch can last anywhere from a few seconds to many minutes, depending on how many access points and client stations are visible.</p> <ul> <li>Epoch: In machine learning, an epoch refers to one complete cycle through the entire dataset. For Pwnagotchi, this means a cycle of interaction with Wi-Fi networks.</li> </ul> <p>Do not expect your Pwnagotchi to perform amazingly well at the very beginning, as it will be exploring several combinations of key parameters to determine ideal adjustments for pwning the particular environment you are exposing it to during its beginning epochs ... but definitely listen to your Pwnagotchi when it tells you it's bored! Bring it into novel WiFi environments with you and have it observe new networks and capture new handshakes\u2014and you'll see. :)</p>"},{"location":"HOW_IT_WORKS/#multi-unit-interaction","title":"Multi-Unit Interaction","text":"<p>Multiple units within close physical proximity can \u201ctalk\u201d to each other, advertising their own presence to each other by broadcasting custom information elements using a parasite protocol I\u2019ve built on top of the existing dot11 standard. Over time, two or more Pwnagotchi units trained together will learn to cooperate upon detecting each other\u2019s presence by dividing the available channels among them for optimal pwnage.</p> <ul> <li> <p>Parasite protocol: A custom protocol developed to allow multiple Pwnagotchi devices to communicate with each other, sharing information about their surrounding networks and synchronizing their activities for more efficient Wi-Fi cracking.</p> </li> <li> <p>dot11 standard: Refers to the IEEE 802.11 standard, which defines the protocols for wireless networking, like Wi-Fi. This is the foundation for how Pwnagotchi interacts with Wi-Fi networks.</p> </li> </ul>"},{"location":"HOW_IT_WORKS/#moods-and-states","title":"Moods and States","text":"<p>Depending on the status of the unit, several states and state transitions are configurable and represented on the display as different moods, expressions, and sentences. Pwnagotchi speaks many languages, too!</p> <ul> <li>Moods: The \"mood\" refers to the way Pwnagotchi expresses its internal state visually and verbally. Moods can change based on how well it is performing or how \"bored\" it is with the environment.</li> </ul> <p>Of course, it IS possible to run your Pwnagotchi with the AI disabled (configurable in <code>config.toml</code>). Why might you want to do this? Perhaps you simply want to use your own fixed parameters (instead of letting the AI decide for you), or maybe you want to save battery and CPU cycles, or maybe it\u2019s just you have strong concerns about aiding and abetting baby Skynet. Whatever your particular reasons may be: an AI-disabled Pwnagotchi is still a simple and very effective automated deauther, WPA handshake sniffer, and portable bettercap + webui dedicated hardware.</p> <ul> <li> <p>Deauther: A tool that performs deauthentication attacks, disrupting Wi-Fi connections and enabling the capture of handshakes for WPA cracking.</p> </li> <li> <p>WebUI: A web user interface that allows you to interact with Pwnagotchi through a browser for easier management and monitoring.</p> </li> </ul> <p>\ud83d\udea7 Work in Progress \ud83d\udea7</p>"},{"location":"Password%20Manager/","title":"Self-Hosting Vaultwarden on Raspberry Pi Zero 2","text":""},{"location":"Password%20Manager/#why","title":"Why?","text":"<p>Many people use simple or reused passwords for online services because they are easier to remember. While I used to do the same, I realized that storing passwords in web browsers is neither secure nor advisable.</p> <p>To improve my security, I decided to set up a self-hosted password manager using Vaultwarden. </p> <p>Vaultwarden is a lightweight, self-hosted alternative to Bitwarden. It provides the same functionality while being optimized for low-resource devices like the Raspberry Pi Zero 2 W. It also offers features like Multi-Factor Authentication (MFA), backups, SSL encryption, and remote access, ensuring better security while giving me full control over my credentials.</p> <p>To achieve this, I used the following hardware:</p> <ul> <li>Raspberry Pi Zero 2 W, compact and low-power makes it ideal for self-hosted applications.</li> <li>Waveshare 2.13 inch e-paper HAT v4</li> <li>MicroSD card with 32Gb</li> <li>Card reader</li> <li>Windows PC</li> </ul>"},{"location":"Password%20Manager/#flash-raspberry-pi-os-lite-64-bit","title":"Flash Raspberry Pi OS Lite (64-bit)","text":"<p>The first step was to flash Raspberry Pi OS Lite (64-bit) onto the microSD card. I used the Raspberry Pi Imager tool to complete this process.</p> <ol> <li>Insert the microSD card into the card reader.</li> <li>Open Raspberry Pi Imager and Choose OS &gt; Raspberry Pi OS (Other) &gt; Raspberry Pi OS Lite (64-bit).</li> <li>Choose the microSD card as the storage device.</li> <li>Click Next, then Edit Settings to configure:  Enable Set hostname, set up a username and password, Configure Wireless LAN and  Enable SSH to allow remote access.</li> </ol> <p>Enabling SSH allows remote access and control over the Raspberry Pi from another device. Since the Raspberry Pi Zero 2 W often runs headless (without a monitor or keyboard), SSH provides a convenient way to configure and manage the system over the network.</p> <ol> <li>Save and click Yes to use the settings, then wait to write.</li> </ol>"},{"location":"Password%20Manager/#connect-over-ssh","title":"Connect Over SSH","text":"<p>Since SSH was enabled at the time of writing the OS, I can now connect to the Raspberry Pi over SSH using PuTTY:</p> <ol> <li>Insert the microSD card into the Raspberry Pi and power it on.</li> <li>Open PuTTY on my Windows PC.</li> <li>Enter the Raspberry Pi's IP address (found via nmap) in the Host Name (or IP address) field.</li> <li>Ensure the Port is set to <code>22</code> and Connection type is SSH.</li> <li>Click Open to initiate the connection.</li> <li>When prompted, enter the username and password set during configuration.</li> </ol>"},{"location":"Password%20Manager/#on-the-terminal","title":"On the terminal","text":"<p>To make sure everything runs smoothly, I started by updating and upgrading the software packages:</p> <pre><code>sudo apt update &amp;&amp; sudo apt full-upgrade -y\n</code></pre>"},{"location":"Password%20Manager/#install-docker-and-portainer","title":"Install Docker and Portainer","text":"<ol> <li>Install Docker: <code>curl -sSL https://get.docker.com | sh</code></li> <li>Grant Docker permissions to my user (joaof): <code>sudo usermod -aG docker joaof</code></li> <li>Rebooted the system for changes to take effect.: <code>sudo reboot</code></li> <li>Although Docker containers can be managed via the command line, Portainer provides a user-friendly GUI interface for deploying and managing our Docker containers on Raspberry Pi. To pull the latest version of Portainer from Docker Hub: <code>sudo docker pull portainer/portainer-ce:latest</code></li> <li>Creating and running a Portainer container. This command exposes the Portainer web interface on port 9000 and ensures Portainer is always restarted if the system reboots.</li> </ol> <pre><code>sudo docker run -d -p 9000:9000 --restart=always --name=portainer -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest\n</code></pre> <ol> <li>With the container running, opened then web browser and accessed the Portainer UI with: <code>http://192.168.1.228:9000</code>.</li> </ol>"},{"location":"Password%20Manager/#install-and-set-up-vaultwarden","title":"Install and Set Up Vaultwarden","text":"<p>After creating a Portainer account, I'll deploy and set up a self-hosted Vaultwarden server on the Pi.</p> <ol> <li>Click on Volume &gt; Add Volume</li> <li>Created a volume named VaultwardenServer</li> <li>Containers &gt; Add Container and did the following:<ul> <li>Name: Vaultwarden</li> <li>Image: vaultwarden/server:1.32.0 (latest was not working) </li> <li>Map an additional port, forwarding 8080 on the host to 80 in the container.</li> <li>Volumes &gt; Map additional volume with <code>/data</code> in the container field and the <code>VaultwardenServer</code>volume created before</li> <li>Under Restart Policy selected <code>Always</code></li> <li>Finally, click Deploy the container and after a few minutes,  the Vaultwarden server is displayed as healthy in the Portainer UI</li> </ul> </li> <li>I can now visit <code>http://192.168.1.228:8080</code> Which opens the Vaultwarden web UI.</li> </ol>"},{"location":"Password%20Manager/#set-up-the-reverse-proxy","title":"Set Up the reverse proxy","text":"<p>To access and use Vaultwarden, I need to set up a reverse proxy. For this I'll be using Nginx Proxy Manager.</p> <ol> <li>Ran the following command to pull the latest nginx image and start the container:</li> </ol> <pre><code>sudo docker run -d \\\n  --name=nginx-proxy-manager \\\n  -p 81:81 \\\n  -p 80:80 \\\n  -p 443:443 \\\n  -v /srv/dev-disk-by-label-Backup/Docker/nginx-proxy-manager/data:/data \\\n  -v /srv/dev-disk-by-label-Backup/Docker/nginx-proxy-manager/letsencrypt:/etc/letsencrypt \\\n  --restart unless-stopped \\\n  jc21/nginx-proxy-manager:latest\n</code></pre> <ol> <li> <p>To check if the container starts successfully, I opened Portainer  and verified that the <code>nginx-proxy-manager</code> container was running. Another way would be to run:  <code>docker ps -a</code>.</p> <p>If the container wasn\u2019t running, check the logs troubleshooting with:  <code>docker logs nginx-proxy-manager</code>.</p> </li> <li> <p>With the container up I can access the Nginx Proxy Manager web UI at  <code>http://192.168.1.228:81</code>.</p> </li> </ol>"},{"location":"Password%20Manager/#securing-vaultwarden-with-https-using-lets-encrypt-duckdns","title":"Securing Vaultwarden with HTTPS Using Let\u2019s Encrypt &amp; DuckDNS","text":"<p>Now that the reverse proxy is set up, I need to secure access  to Vaultwarden with HTTPS. I'll use DuckDNS for dynamic DNS,   and Let\u2019s Encrypt to generate a free SSL certificate.  </p> <p>This will allow me to access Vaultwarden securely from anywhere  without relying on a static IP or a paid domain.</p>"},{"location":"Password%20Manager/#set-up-duckdns","title":"Set Up DuckDNS","text":"<ol> <li>Visited DuckDNS and created an account.  </li> <li>Added a new subdomain chaveman.duckdns.org and  linked it to my IPv4 address.  </li> <li>Copied my DuckDNS Token from the page (I'll need it later).</li> </ol>"},{"location":"Password%20Manager/#generate-an-ssl-certificate-using-lets-encrypt","title":"Generate an SSL Certificate Using Let's Encrypt","text":"<ol> <li>Used Certbot with the DNS-01 challenge to obtain an SSL certificate  for my DuckDNS domain: Ran the following command to request a certificate using the DNS-01 challenge:  </li> </ol> <pre><code>sudo apt update &amp;&amp; sudo apt install certbot -y\nsudo certbot certonly --manual --preferred-challenges dns -d chaveman.duckdns.org\n</code></pre> <ol> <li>Certbot provided a TXT record that needs to be added to DNS for verification. Using DuckDNS's update URL: <code>https://www.duckdns.org/update?domains=chaveman&amp;token=MY_TOKEN&amp;txt=TXTVALUE&amp;verbose=true</code> i got an OK and this means DuckDNS set my TXT record.</li> <li>To make sure that the TXT Record was Published waited a couple of minutes for DNS to propagate and using Google Admin Toolbox (Dig) I could see my  TXT Value value under the ANSWER section so we're good to go.</li> <li>Pressed Enter and Certbot created two cert files <code>fullchain.pem</code> and <code>privkey.pem</code> in <code>/etc/letsencrypt/live/Vaultwarden.duckdns.org/</code>.</li> <li><code>sudo certbot certificates</code> to check the certificates expirity date,  was 90 days so to make it automaticaly renew: <code>sudo crontab -e</code> to open the crontab file with NANO and added the cron job <code>0 0 * * * certbot renew --quiet</code> which will run Certbot command to renew the SSL certificates automatically, ensuring the website's encryption remains valid without manual intervention.</li> </ol>"},{"location":"Password%20Manager/#nginx-proxy-manager","title":"Nginx Proxy Manager","text":"<p>Since the Web UI\u2019s file explorer only shows local files, I had to copy the cert files from the Raspberry Pi to my local machine so they could be uploaded.</p> <ol> <li>Copy the cert files to my local machine using <code>scp</code> (secure copy):</li> </ol> <pre><code>  scp joaof@192.168.1.228:/etc/letsencrypt/live/Vaultwarden.duckdns.org/fullchain.pem /home/joaof/Documents/Certificates\n  scp joaof@192.168.1.228:/etc/letsencrypt/live/Vaultwarden.duckdns.org/privkey.pem /home/joaof/Documents/Certificates\n</code></pre> <ol> <li>Returned to the Nginx Proxy Manager Web UI &gt; SSL Certificates &gt;  Add SSL Certificate &gt; Custom and selected the cert files: </li> <li>Add Proxy Host: </li> <li>Under SSL: </li> </ol> <p>At this point I should've been able to connect to https://chaveman.duckdns.org but i was getting an SSL error on the browser and using Port Checker I can see that my ISP is blocking inbound traffic for port 443.</p> <ol> <li>Access my router configurations to port forward the 443 port to the rpi.</li> <li>Finally connect to https://chaveman.duckdns.org and access Vaultwarden.</li> </ol>"},{"location":"Password%20Manager/#enhancing-vaultwarden-with-an-e-paper-display","title":"Enhancing Vaultwarden with an E-Paper Display","text":"<ol> <li>Enabled SPI on my Raspberry Pi by running: <code>sudo raspi-config</code></li> <li>Navigated to Interfacing Options &gt; SPI &gt; Enable</li> <li>After enabling SPI, I rebooted the system: <code>sudo reboot</code></li> <li>Installing the necessary Python libraries:</li> </ol> <pre><code>sudo apt-get update\nsudo apt-get install python3-pip python3-pil python3-numpy\nsudo apt-get install python3-spidev python3-rpi.gpio\nsudo apt-get install python3-psutil\n</code></pre> <ol> <li>Cloned the waveshareteam repo and moved into the correct directory: </li> </ol> <pre><code>git clone https://github.com/waveshare/e-Paper.git\ncd ~/e-Paper/RaspberryPi_JetsonNano/python\n</code></pre> <ol> <li>For the Waveshare 2.13-inch v4 display, I used the <code>epd2in13_V4</code> module from <code>../lib/waveshare_epd</code> and tested it using <code>../examples/epd2in13_V4_test.py</code>. From there, I built system_monitor_v1 to display system info like temperature, uptime, and IP address.</li> </ol> <p>outra possibilidade seria obter um dominio e cloudflare tunnel</p> <p>\ud83d\udea7 Work in Progress \ud83d\udea7</p>"},{"location":"PwnZilla%20Guia/","title":"PwnZilla","text":""},{"location":"PwnZilla%20Guia/#overview","title":"\ud83d\udccc Overview","text":"<p>This project documents my journey of setting up and customizing a Pwnagotchi from scratch.</p> <p>The Pwnagotchi is an A2C-based \u201cAI\u201d powered by Bettercap. It learns from its surrounding WiFi environment to maximize the collection of crackable WPA key material. This can include material captured via passive sniffing or through deauthentication and association attacks.</p> <p>Originally created by EvilSocket, the project wasn't actively maintained for a while, but it was later picked up and continued by Jayofelony. For more up-to-date information, you can refer to both the new website and the original one.</p> <p>I\u2019ll be using Jayofelony's image (v2.8.9), 64-bit, as I\u2019m working with a Raspberry Pi Zero 2 W. If you\u2019re using different hardware, you can check the available images and choose the one that matches your setup.</p> <p>I\u2019ve chosen to use jayofelony\u2019s v2.8.9 image because the AI feature was removed in the later release.</p> <p>For this setup, I\u2019ll be using Windows as my main operating system, along with PuTTY for SSH access and 7-Zip to extract the image file. Additionally, I\u2019ll need RNDIS drivers, which can be downloaded from ModCloud here</p> <p>If you\u2019re looking for a deeper explanation of how the Pwnagotchi works, feel free to check out in depth info.</p> <p> </p>"},{"location":"PwnZilla%20Guia/#hardware","title":"Hardware","text":"<ul> <li>Raspberry Pi Zero 2W with headers </li> <li>MicroSD Card 32Gb but 8Gb would be enough </li> <li>Waveshare v4 2.13Inch e-Paper HAT</li> <li>Micro USB Data+Power Raspberry Pi cable  </li> <li>Power bank  </li> </ul>"},{"location":"PwnZilla%20Guia/#installation-flashing","title":"Installation &amp; Flashing","text":"<ol> <li>Downloaded v2.8.9 from jayofelony's repo</li> <li>Flashing the image using the Raspberry Pi Imager</li> </ol>"},{"location":"PwnZilla%20Guia/#configurations","title":"Configurations","text":""},{"location":"pt/","title":"~$ whoami","text":"<p>Jo\u00e3o \u2013 tech enthusiast, breaker of things, occasional fixer </p> <p>Hey, my name is Jo\u00e3o and I\u2019m a tech enthusiast who loves breaking things, not always fixing them, and sometimes learning along the way. I\u2019m currently a student, so between classes and life, I try to spend time diving into cybersecurity, playing CTFs, pwning machines on TryHackMe and HackTheBox, and tinkering with electronics.  </p> <p>This repo is basically my personal brain dump, where I document my projects, things I\u2019m learning, and random experiments.  </p> <p>\ud83d\udea7 Still a work in progress... updates will come whenever I get around to it! \ud83d\ude06  </p>"},{"location":"pt/Air%20Monitor/#hardware","title":"Hardware","text":"<ul> <li> <p>ESP32C6 - Dispositivo central respons\u00e1vel pela recolha e transmiss\u00e3o de dados via WiFi 6 e Bluetooth 5, garantindo uma comunica\u00e7\u00e3o eficiente com os sensores.  </p> </li> <li> <p>SHT41 - Sensor de temperatura e humidade com maior precis\u00e3o do que os comuns DHT11 e DHT22. Comunica via I2C e permite medi\u00e7\u00f5es de temperatura entre -40\u00b0C e 125\u00b0C e de humidade entre 0% e 100%.  </p> </li> <li> <p>Senseair S8 \u2013 Sensor de CO\u2082 do tipo NDIR (Non-Dispersive Infrared). Mede concentra\u00e7\u00f5es entre 400 e 5000 ppm, com uma precis\u00e3o de \u00b140 ppm + 3% da leitura, comunicando via UART.  </p> <p>Possui um sistema de ABC (Automatic Baseline Correction) ativo por padr\u00e3o, que torna o sensor praticamente livre de manuten\u00e7\u00e3o em ambientes normais. Este algoritmo realiza uma corre\u00e7\u00e3o autom\u00e1tica de deriva ao longo do tempo, assumindo que o sensor ser\u00e1 exposto periodicamente a ar fresco com uma concentra\u00e7\u00e3o de 400 ppm de CO\u2082.  </p> <p>O ciclo padr\u00e3o de corre\u00e7\u00e3o ocorre a cada 15 dias de opera\u00e7\u00e3o cont\u00ednua, \u00e9 aconselhado deixar o sensor ativo por pelo menos 25 dias para garantir que estou a receber medi\u00e7\u00f5es precisas.</p> </li> <li> <p>Plantower PMS2.5 - Sensor de part\u00edculas em suspens\u00e3o (PM), capaz de medir PM1.0, PM2.5 e PM10. Permite identificar part\u00edculas com di\u00e2metros m\u00ednimos de 0.3 \u00b5m, sendo \u00fatil para monitorizar poeira, fumo e polui\u00e7\u00e3o urbana. Comunica via UART.  </p> </li> <li> <p>Panasonic SN-GCJA5 \u2013 Sensor de part\u00edculas Laser-based de alta precis\u00e3o, usado para medir PM1.0, PM2.5 e PM10 (Particulate Matter). Baseia-se no princ\u00edpio de dispers\u00e3o de luz (light scattering) usando um laser interno e um fotodiodo sens\u00edvel para detetar part\u00edculas suspensas no ar.  </p> <p>Possui uma ventoinha interna que garante fluxo de ar constante atrav\u00e9s da c\u00e2mara de medi\u00e7\u00e3o, o que melhora a fiabilidade das leituras. A comunica\u00e7\u00e3o \u00e9 feita via UART ou I2C.  </p> <p>O sensor tem uma elevada sensibilidade, sendo capaz de detetar part\u00edculas com di\u00e2metros inferiores a 1 \u00b5m. As leituras s\u00e3o fornecidas em \u03bcg/m\u00b3. </p> </li> </ul>"},{"location":"pt/Air%20Monitor/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<p>Para n\u00e3o seguir o caminho tradicional com Arduino IDE e experimentar algo novo, decidi utilizar ESP IDF. \u00c9 uma op\u00e7\u00e3o mais flex\u00edvel, permitindo testar rapidamente os sensores sem complica\u00e7\u00e3o.  </p> Clique aqui para ver o guia t\u00e9cnico detalhado de configura\u00e7\u00e3o do ambiente   ### **Configurar o ESP32-C6**    O ESP32-C6 vem sem **ESP IDF** instalado, ent\u00e3o \u00e9 necess\u00e1rio **flashar o firmware** antes de come\u00e7ar.    #### **1. Instalar o esptool**   Antes de tudo, precisamos do **esptool**, que serve para interagir com microcontroladores ESP. Como j\u00e1 tenho **Python** instalado, basta abrir o **cmd** e executar:    <pre><code>pip install esptool\n</code></pre>    #### **2. Ligar o ESP32-C6 ao PC**   A parte mais complicada... conectar o ESP32-C6 ao PC usando um **cabo USB-C para USB-A** \ud83d\ude06.    #### **3. Instalar os drivers USB to UART**   Para que o ESP32-C6 seja reconhecido corretamente, precisamos dos **USB to UART Bridge VCP Drivers**.    - O download pode ser feito diretamente em [Silicon Labs](https://www.silabs.com/developer-tools/usb-to-uart-bridge-vcp-drivers?tab=downloads).   - Ap\u00f3s o download, extrair os ficheiros e localizar **`silabser.inf`**.   - Clicar com o **bot\u00e3o direito** e selecionar **Instalar**.    Agora, no **Device Manager**, o dispositivo deve aparecer como **Silicon Labs CP210x USB to UART Bridge (COMx)**.   Tomar nota do n\u00famero da porta COM atribu\u00edda (no meu caso, **COM3**).    #### **4. Limpar a flash do ESP32-C6**   Antes de instalar o firmware, conv\u00e9m limpar a mem\u00f3ria do ESP para evitar problemas. No terminal, correr:  ``python -m esptool --port COM3 erase_flash``  Se tudo correr bem, deve aparecer a mensagem: **Chip erase completed successfully**.  #### **5. Instalar o ESP-IDF**   Podemos fazer download da vers\u00e3o mais recente para **Windows** do [**ESP-IDF**](https://idf.espressif.com/) para o ESP32-C6 neste [link](https://docs.espressif.com/projects/esp-idf/en/stable/esp32c6/get-started/windows-setup.html).    Durante o processo de instala\u00e7\u00e3o, selecionei a op\u00e7\u00e3o de criar **atalhos no ambiente de trabalho**, facilitando o acesso ao **ESP-IDF Command Prompt** e ao **IDE**.    #### **6. Testar com Hello World**   Depois de instalado, podemos verificar se tudo est\u00e1 a funcionar corretamente com um pequeno teste:    - Abir o ESP-IDF CMD e navegar at\u00e9 ao exemplo j\u00e1 inclu\u00eddo de **Hello World**:   `` cd %IDF_PATH%\\examples\\get-started\\hello_world `` - Definir o **target** para a nossa board ESP32-C6:   `` idf.py set-target esp32c6 `` - Fazer **build** do firmware:   `` idf.py build `` - Flashar o firmware para a board:   `` idf.py -p COM3 flash `` - Confirmar que est\u00e1 a imprimir **Hello World**, visualizando o output do **serial monitor**:   `` idf.py -p COM3 monitor `` --- ### **Liga\u00e7\u00f5es**   Como refer\u00eancia para as liga\u00e7\u00f5es, utilizo esta imagem da **board** que estou a usar:   ![ssl](images/ESP32-C6.png)    Conforme mencionado na sec\u00e7\u00e3o de **hardware**, os sensores comunicam da seguinte forma:   - **Senseair S8** e **Plantower PMS2.5** \u2192 UART   - **SHT41** \u2192 I2C    ---  ## **Configura\u00e7\u00e3o de Dados**    Para armazenar e visualizar os dados dos sensores, utilizei o **InfluxDB**, o **Mosquitto MQTT Broker** e o **Telegraf** para integrar os servi\u00e7os.    ### **1. Instalar e configurar o InfluxDB**    1. Fazer **download** da vers\u00e3o mais recente do **InfluxDB v2** no [site oficial](https://www.influxdata.com/).   2. Abrir o **PowerShell** em modo **Administrador** e navegar at\u00e9 a pasta de **Downloads**.   3. Executar o seguinte comando para extrair os ficheiros:    <pre><code>Expand-Archive .\\influxdb2-2.7.11-windows.zip -DestinationPath 'C:\\Program Files\\InfluxData'\n</code></pre>   4. Clicar com o **bot\u00e3o direito** no **.exe**, copiar o **caminho completo** e abrir o **CMD**.   5. Colar o **caminho** copiado e pressionar **Enter**.    O **WebUI** do **InfluxDB** deve abrir em `http://localhost:8086`.   Criar uma conta e seguir as instru\u00e7\u00f5es iniciais.    ---  ### **2. Instalar e configurar o Mosquitto MQTT Broker**    1. Fazer **download** do **Mosquitto** no [site oficial](https://mosquitto.org/download/).   2. Ap\u00f3s a instala\u00e7\u00e3o, abrir o **CMD**, navegar at\u00e9 a pasta de instala\u00e7\u00e3o e iniciar o servi\u00e7o com:  ``mosquitto``   #### **Testar a comunica\u00e7\u00e3o MQTT**   Abrir dois **CMDs**:    - **CMD 1** (para subscrever a um t\u00f3pico):    <pre><code>\"C:\\Program Files\\mosquitto\\mosquitto_sub.exe\" -h 127.0.0.1 -t test/topic\n</code></pre>    - **CMD 2** (para publicar uma mensagem no t\u00f3pico):    <pre><code>\"C:\\Program Files\\mosquitto\\mosquitto_pub.exe\" -h 127.0.0.1 -t test/topic -m \"Hello from Mosquitto\"\n</code></pre>    Se a mensagem **\"Hello from Mosquitto\"** aparecer no primeiro terminal, a comunica\u00e7\u00e3o MQTT est\u00e1 a funcionar corretamente.    Agora, precisamos de conectar o **Mosquitto** ao **InfluxDB** atrav\u00e9s do **Telegraf** e do **MQTT Consumer**.    ---  ### **3. Instalar e configurar o Telegraf**    1. Fazer **download** do **Telegraf** no [site oficial](https://www.influxdata.com/time-series-platform/telegraf/).   2. No **PowerShell** (modo Administrador), executar:    <pre><code>wget https://dl.influxdata.com/telegraf/releases/telegraf-1.34.0_windows_amd64.zip -UseBasicParsing -OutFile telegraf-1.34.0_windows_amd64.zip\n</code></pre>   3. Ap\u00f3s o **download**, extrair os ficheiros:    <pre><code>Expand-Archive .\\telegraf-1.34.0_windows_amd64.zip -DestinationPath 'C:\\Program Files\\InfluxData\\telegraf'\n</code></pre>    ---  ### **4. Configurar o Telegraf para consumir MQTT**    1. No **WebUI** do InfluxDB, criar um **Telegraf Configuration File**:   - Escolher o **bucket Sensores**.   - Selecionar o **plugin MQTT Consumer** na **Plugin Library**.   - Adicionar os seguintes **inputs**:    <pre><code>[[inputs.mqtt_consumer]] servers = [\"tcp://127.0.0.1:1883\"] topics = [ \"sensores/sht41/temperature\", \"sensores/sht41/humidity\", \"sensores/gcja5/pm1\", \"sensores/gcja5/pm2.5\", \"sensores/gcja5/pm10\", \"sensores/sensair_s8/co2\" ] data_format = \"influx\"\n</code></pre>    2. Adicionar o **Token de Autentica\u00e7\u00e3o** conforme indicado no WebUI.    ---  ### **5. Testar a configura\u00e7\u00e3o**    Abrir dois **CMDs**:    - **CMD 1** (para monitorizar os dados recebidos pelo Telegraf):    <pre><code>telegraf --config http://localhost:8086/api/v2/telegrafs/0e96aec27fc2a000 --debug\n</code></pre>    - **CMD 2** (para enviar dados de teste via Mosquitto):    <pre><code>mosquitto_pub -h 127.0.0.1 -t sensores/sht41/temperature -m \"temperature,location=office value=25.3\"\n</code></pre>    Se tudo estiver configurado corretamente, o terminal deve exibir a mensagem de sucesso:    **[outputs.influxdb_v2] Wrote batch of 1 metrics in 5.0302ms**  ---  ### **6. Visualizar os dados no InfluxDB**    1. Aceder ao **WebUI** do **InfluxDB**.   2. Ir a **Data Explorer** e abrir o **Script Editor**.   3. Executar a seguinte **query** para visualizar os dados:    <pre><code>from(bucket: \"Sensores\") |&gt; range(start: -1h) |&gt; filter(fn: (r) =&gt; r._measurement == \"temperature\" or r._measurement == \"humidity\")\n</code></pre>    Os valores dos sensores aparecem no gr\u00e1fico como desejado.    <p>\ud83d\udea7 Work in Progress \ud83d\udea7</p>"},{"location":"pt/Password%20Manager/","title":"Auto-hospedagem do Vaultwarden no Raspberry Pi Zero 2","text":""},{"location":"pt/Password%20Manager/#porque","title":"Porqu\u00ea?","text":"<p>Muitas pessoas utilizam palavras-passe simples ou reutilizadas online porque s\u00e3o mais f\u00e1ceis de memorizar.Embora eu fizesse o mesmo, percebi que armazenar palavras-passe nos browsers n\u00e3o \u00e9 de todo seguro nem aconselh\u00e1vel.  </p> <p>Para melhorar a minha seguran\u00e7a, decidi fazer este projeto de um gestor de palavras-passe caseiro utilizando Vaultwarden.  </p> <p>O Vaultwarden \u00e9 uma alternativa leve e \"auto-hospedada\" ao Bitwarden. As funcionalidades s\u00e3o as mesmas, mas \u00e9 otimizado para dispositivos de baixo consumo como o Raspberry Pi Zero 2W. Al\u00e9m disso, inclui funcionalidades como Autentica\u00e7\u00e3o Multi-Fator (MFA), backups, encripta\u00e7\u00e3o SSL e acesso remoto, garantindo uma maior seguran\u00e7a enquanto mantenho o controlo total sobre os meus logins. </p> <p>Para alcan\u00e7ar este objetivo, utilizei o seguinte hardware:  </p> <ul> <li>Raspberry Pi Zero 2 W, compacto e de baixo consumo, ideal para este tipo de aplica\u00e7\u00f5es.  </li> <li>Waveshare 2.13 polegadas e-paper HAT v4 </li> <li>Cart\u00e3o MicroSD de 32GB, 16Gb chega mas why not.</li> <li>Leitor de cart\u00f5es </li> <li>PC com Windows </li> </ul>"},{"location":"pt/Password%20Manager/#flashar-o-raspberry-pi-os-lite-64-bits","title":"Flashar o Raspberry Pi OS Lite (64 bits)","text":"<p>O primeiro passo foi flashar o Raspberry Pi OS Lite (64 bits) no cart\u00e3o microSD. Utilizei a ferramenta Raspberry Pi Imager para este efeito.  </p> <ol> <li>Inserir o cart\u00e3o microSD no leitor de cart\u00f5es (obvio).  </li> <li>Abrir o Raspberry Pi Imager e selecionar Choose OS &gt; Raspberry Pi OS (Other) &gt; Raspberry Pi OS Lite (64-bit).  </li> <li>Escolher o cart\u00e3o microSD como dispositivo de armazenamento.  </li> <li>Clicar em Next e depois em Edit Settings para configurar:  </li> <li>Ativar Set hostname, definir um nome de utilizador e palavra-passe, Configurar Wireless LAN e ativar SSH para permitir o acesso remoto.  </li> </ol> <p>Ao ativar o SSH (secure shell) consigo aceder e controlar remotamente o meu Raspberry Pi a partir de outro dispositivo. Como o Raspberry Pi Zero 2W \u00e9 frequentemente utilizado sem monitor ou teclado (headless), ter SSH torna-se uma forma conveniente de configurar e gerir o sistema atrav\u00e9s da rede.  </p> <ol> <li>Guardar e clicar em Sim para utilizar as defini\u00e7\u00f5es, depois aguardar a grava\u00e7\u00e3o.</li> </ol>"},{"location":"pt/Password%20Manager/#ligar-via-ssh","title":"Ligar via SSH","text":"<p>Como ativei o SSH durante a instala\u00e7\u00e3o do sistema operativo, posso agora ligar-me ao Raspberry Pi via SSH utilizando o PuTTY:  </p> <ol> <li>Inserir o cart\u00e3o microSD no Raspberry Pi e lig\u00e1-lo \u00e0 corrente.  </li> <li>Abrir o PuTTY no PC com Windows.  </li> <li>Introduzir o endere\u00e7o IP do Raspberry Pi (obtido via nmap) no campo Host Name (or IP address).  </li> <li>Certificar-me de que a Porta est\u00e1 definida para <code>22</code> e o Tipo de conex\u00e3o \u00e9 SSH.  </li> <li>Clicar em Open para iniciar a liga\u00e7\u00e3o.  </li> <li>Quando solicitado, introduzir o nome de utilizador e a palavra-passe definidos na configura\u00e7\u00e3o.  </li> </ol>"},{"location":"pt/Password%20Manager/#no-terminal","title":"No terminal","text":"<p>Para garantir que tudo corre sem problemas, comecei por atualizar e atualizar os pacotes de software:  </p> <pre><code>sudo apt update &amp;&amp; sudo apt full-upgrade -y\n</code></pre>"},{"location":"pt/Password%20Manager/#instalar-docker-e-portainer","title":"Instalar Docker e Portainer","text":"<ol> <li>Instalar o Docker:   <code>curl -sSL https://get.docker.com | sh</code></li> <li>Conceder permiss\u00f5es do Docker ao meu utilizador (joaof):  <code>sudo usermod -aG docker joaof</code></li> <li>Reiniciar o sistema para aplicar as altera\u00e7\u00f5es: <code>sudo reboot</code></li> <li>Obter a vers\u00e3o mais recente do Portainer: <code>sudo docker pull portainer/portainer-ce:latest</code></li> <li>Criar e executar um contentor Portainer: <code>bash    sudo docker run -d -p 9000:9000 --restart=always --name=portainer -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest</code></li> <li>Abrir um navegador web e aceder \u00e0 interface do Portainer em: <code>http://192.168.1.228:9000</code></li> </ol>"},{"location":"pt/Password%20Manager/#instalar-e-configurar-o-vaultwarden","title":"Instalar e Configurar o Vaultwarden","text":"<p>Depois de criar uma conta no Portainer, segui estes passos para instalar e configurar o Vaultwarden no Raspberry Pi.  </p> <ol> <li>Volumes &gt; Adicionar Volume </li> <li>Criar um volume chamado VaultwardenServer </li> <li>Contentores &gt; Adicionar Contentor e configurar da seguinte forma:  </li> <li>Nome: Vaultwarden  </li> <li>Imagem: vaultwarden/server:1.32.0 (a vers\u00e3o mais recente n\u00e3o estava a funcionar)</li> <li>Mapear as portas: 8080 no host \u2192 80 no contentor.  </li> <li>Volumes: associar o volume criado (VaultwardenServer) ao diret\u00f3rio <code>/data</code> no contentor.  </li> <li>Pol\u00edtica de rein\u00edcio: Always </li> <li> <p>Dar Deploy ao contentor e Ap\u00f3s alguns minutos, o Vaultwarden aparece como Healthy na interface do Portainer.  </p> </li> <li> <p>Agora j\u00e1 posso aceder \u00e0 interface web do Vaultwarden em: <code>http://192.168.1.228:8080</code></p> </li> </ol>"},{"location":"pt/Password%20Manager/#fazer-a-reverse-proxy","title":"Fazer a Reverse Proxy","text":"<p>Para aceder ao Vaultwarden de forma segura via HTTPS, utilizei um reverse proxy com o amigo Nginx Proxy Manager.  </p> <ol> <li>Instalar e iniciar o contentor Nginx Proxy Manager: <code>bash    sudo docker run -d \\      --name=nginx-proxy-manager \\      -p 81:81 \\      -p 80:80 \\      -p 443:443 \\      -v /srv/dev-disk-by-label-Backup/Docker/nginx-proxy-manager/data:/data \\      -v /srv/dev-disk-by-label-Backup/Docker/nginx-proxy-manager/letsencrypt:/etc/letsencrypt \\      --restart unless-stopped \\      jc21/nginx-proxy-manager:latest</code></li> <li> <p>Para verificar se o contentor iniciou com sucesso, abri o Portainer e confirmei que o contentor <code>nginx-proxy-manager</code> estava em execu\u00e7\u00e3o. Outra forma seria executar: <code>docker ps -a</code>. </p> <p>Se o contentor n\u00e3o estivesse a correr, para resolver problemas ver os logs com: <code>docker logs nginx-proxy-manager</code>.</p> </li> <li> <p>Aceder \u00e0 interface web do nginx proxy manager em:  <code>http://192.168.1.228:81</code></p> </li> </ol>"},{"location":"pt/Password%20Manager/#proteger-o-vaultwarden-com-https-usando-duckdns-e-lets-encrypt","title":"Proteger o Vaultwarden com HTTPS usando DuckDNS e Let's Encrypt","text":"<p>Agora que a reverse proxy est\u00e1 configurada, \u00e9 preciso garantir o acesso seguro ao Vaultwarden com HTTPS. Vou usar o DuckDNS para DNS din\u00e2mico e o Let\u2019s Encrypt para gerar um certificado SSL gratuito.  </p> <p>Isto vai me permitir aceder ao Vaultwarden de forma segura a partir de qualquer lugar, sem depender de um IP fixo ou de um dom\u00ednio pago.  </p>"},{"location":"pt/Password%20Manager/#configurar-o-duckdns","title":"Configurar o DuckDNS","text":"<ol> <li>Entrei no site DuckDNS e criei uma conta gr\u00e1tis.  </li> <li>Adicionei um novo subdom\u00ednio <code>chaveman.duckdns.org</code> e associei-o ao meu endere\u00e7o IPv4.  </li> <li>Copiei o meu Token do DuckDNS da p\u00e1gina (vou precisar dele mais tarde).  </li> </ol>"},{"location":"pt/Password%20Manager/#gerar-um-certificado-ssl-usando-lets-encrypt","title":"Gerar um Certificado SSL usando Let's Encrypt","text":"<ol> <li>Usei o Certbot com o Desafio DNS-01 para obter um certificado SSL para o meu dom\u00ednio DuckDNS. Executei o seguinte comando para solicitar um certificado:  </li> </ol> <pre><code>sudo apt update &amp;&amp; sudo apt install certbot -y\nsudo certbot certonly --manual --preferred-challenges dns -d chaveman.duckdns.org\n</code></pre> <ol> <li> <p>O Certbot forneceu um registo TXT que tem de ser adicionado ao DNS para verifica\u00e7\u00e3o.  Utilizando o URL de atualiza\u00e7\u00e3o do DuckDNS: <code>https://www.duckdns.org/update?domains=chaveman&amp;token=MEU_TOKEN&amp;txt=VALOR_TXT&amp;verbose=true</code> recebi um OK, o que significa que o DuckDNS configurou corretamente o meu registo TXT.</p> </li> <li> <p>Para garantir que o registo TXT foi publicado, esperei alguns minutos para a propaga\u00e7\u00e3o do DNS. Utilizando o Google Admin Toolbox (Dig), confirmei que o meu valor TXT aparecia na sec\u00e7\u00e3o ANSWER, o que significa que estava pronto para prosseguir.</p> </li> <li> <p>Carreguei em Enter e o Certbot criou dois ficheiros pem:     fullchain.pem e privkey.pem na pasta:     <code>/etc/letsencrypt/live/Vaultwarden.duckdns.org/</code></p> </li> <li> <p>Para verificar a validade dos certificados, executei:     <code>sudo certbot certificates</code> e verifiquei que os certificados eram v\u00e1lidos por 90 dias, por isso, para renov\u00e1-los automaticamente, abri o ficheiro de crontab com o comando:  <code>sudo crontab -e</code>  Adicionei a seguinte tarefa cron: <code>0 0 * * * certbot renew --quiet</code> Isto permite que o Certbot renove automaticamente os certificados SSL, garantindo que a encripta\u00e7\u00e3o do site se mant\u00e9m v\u00e1lida sem necessidade de interven\u00e7\u00e3o manual.</p> </li> </ol>"},{"location":"pt/Password%20Manager/#nginx-proxy-manager","title":"Nginx Proxy Manager","text":"<p>Uma vez que o explorador de ficheiros da Web UI apenas mostra ficheiros locais, tive de copiar os ficheiros de certificado do Raspberry Pi para o meu computador para que pudessem ser carregados.</p> <ol> <li>Copiar os ficheiros de certificado para o meu computador usando <code>scp</code> (secure copy):</li> </ol> <pre><code>  scp joaof@192.168.1.228:/etc/letsencrypt/live/Vaultwarden.duckdns.org/fullchain.pem /home/joaof/Documents/Certificates\n  scp joaof@192.168.1.228:/etc/letsencrypt/live/Vaultwarden.duckdns.org/privkey.pem /home/joaof/Documents/Certificates\n  ```\n2. Voltar \u00e0 **Web UI do Nginx Proxy Manager** &gt; **SSL Certificates** &gt;\n**Add SSL Certificate** &gt; **Custom** e selecionar os ficheiros de certificado:\n![certificados](images/SSL_Certificate.png)\n3. **Adicionar Proxy Host**:\n![adicionarproxyhost](images/ProxyHost.png)\n4. Em **SSL**:\n![ssl](images/SSLProxyHost.png)\n\nNeste momento j\u00e1 deveria ser poss\u00edvel ligar-me a https://chaveman.duckdns.org, mas estava a obter um erro SSL no navegador. Usando o [Port Checker](https://portchecker.co/), percebi que o meu ISP estava a bloquear o tr\u00e1fego de entrada na porta 443.\n\n5. Aceder \u00e0s configura\u00e7\u00f5es do router para encaminhar a porta 443 para o Raspberry Pi.\n6. Finalmente, posso me conectar a https://chaveman.duckdns.org e aceder ao Vaultwarden.\n\n### Melhorar este projeto com um E-Paper Display\n\n1. Ativar SPI no Raspberry Pi executando: ``sudo raspi-config``\n2. Navegar at\u00e9 **Interfacing Options** &gt; **SPI** &gt; **Enable**\n3. Ap\u00f3s ativar o SPI, reiniciar o sistema: ``sudo reboot``\n4. Instalar as bibliotecas Python necess\u00e1rias:\n```bash\nsudo apt-get update\nsudo apt-get install python3-pip python3-pil python3-numpy\nsudo apt-get install python3-spidev python3-rpi.gpio\nsudo apt-get install python3-psutil\n</code></pre> <ol> <li>Clonei o reposit\u00f3rio da waveshareteam e entrei na pasta correta:</li> </ol> <pre><code>git clone https://github.com/waveshareteam/e-Paper.git\ncd ~/e-Paper/RaspberryPi_JetsonNano/python\n</code></pre> <ol> <li>Para o meu e-paper Waveshare de 2.13 polegadas v4, utilizei o respectivo m\u00f3dulo epd2in13_V4 de <code>../lib/waveshare_epd</code> e testei-o com <code>../examples/epd2in13_V4_test.py</code>. A partir da\u00ed, constru\u00ed o system_monitor_v1 para exibir informa\u00e7\u00f5es do sistema, como temperatura, tempo de atividade e endere\u00e7o IP.</li> </ol> <p></p> <p>outra possibilidade seria obter um dominio e cloudflare tunnel</p> <p>\ud83d\udea7 Work in Progress \ud83d\udea7</p>"},{"location":"pt/PwnZilla%20Guia/#configurations","title":"Configurations","text":"<p>\ud83d\udea7 Writting in Progress \ud83d\udea7</p>"},{"location":"pt/AirMonitor/","title":"Sensor de Monitoriza\u00e7\u00e3o do Ar para Casa","text":"<p>Um dos poucos pontos positivos que o Covid-19 nos trouxe foi um abre olhos para a realidade que h\u00e1 coisas presentes nos nossos ambientes indoors que podem ser prejudiciais para a nossa saude, e que os nossos sentidos primarios como o olfato, o paladar e a vis\u00e3o n\u00e3o nos podem ajudar. </p> <p>Aqui entram os monotorizadores de indoor air quality (IAQ): Podem detetar a presenca de substancias contaminadoras e informar-nos acerca de niveis de polui\u00e7\u00e3o que requerem cau\u00e7\u00e3o e a\u00e7\u00e3o. Quantos mais dados objetivos dispon\u00edveis, melhor a capacidade de tomada de decis\u00e3o para podermos controlar um ambiente indoors de forma informada e para que ele seja saudavel.</p>"},{"location":"pt/AirMonitor/#mais-importantes","title":"mais importantes","text":"<p>H\u00e1 varios parametros que convem medir mas os principais s\u00e3o:</p> <p>Temperatura e Humidade - saber os valores de temperatura e de humidade de um local ajudam a identificar quando o ambiente esta muito humido o que aumenta o risco de crescimento de bacterias e bolor. Alguns dispositivos podem ainda calcular o ponto de orvalho - o ponto de temperatura em que o ar j\u00e1 nao consegue conter mais vapor de agua.</p> <p>CO2 - \u00e9 um composto quimico que n\u00f3s humanos libertamos para o ar. niveis altos deste composto pode levar a cansa\u00e7o e falta de produtividade ent\u00e3o uma monotorizacao dos niveis de co2 permite saber se a nossa casa tem ventila\u00e7\u00e3o suficiente.</p> <p>Particule Matter - As particule matters s\u00e3o um mix de particulas solidas e particulas de suspensao de tamanho t\u00e3o reduzido que podem ser inspiradad para os nossos pulmoes. estas particulas podem ser geradas por fumo, p\u00f3, etc. Dentro das PM temos PM10 com diametros &lt;10 micro metros e as mais perigosas para a saude PM2.5 com diametro &lt;2.5 micro metros. Para comparacao um cabelo humano tem aproximadamente 70 micro metros de diametro.</p>"},{"location":"pt/AirMonitor/#hardware","title":"Hardware","text":"<p>ESP32C6 - dispositivo central de recolha de dados que possui wifi para transmissao dos mesmos.</p> <p>SHT41 - sensor de temperatura e humidade com melhores especificacoes do que os mais comuns dht11 e dht22.</p> <p>Senseair S8 - um sensor non dispersive infrared (NDIR) com boa precisao</p> <p>Planttower PMS2.5 - sensor de PM</p> <p>OLED I2C 128x64 SSD1306 - um ecra monocromatico para visualizacao de dados.</p>"},{"location":"pt/AirMonitor/#implementacao","title":"Implementac\u00e3o","text":"<p>O objetivo \u00e9 no final ter uma vers\u00e3o de desenvolvimento que ser\u00e1 desenvolvida para o esp idf. no entanto para teste dos sensores e conectividade vou usar o arduino ide para fazer uso das bibliotecas que s\u00e3o disponibilizadas para estes sensores.</p> Clique aqui para ver o guia t\u00e9cnico detalhado de configura\u00e7\u00e3o do ambiente   ### configurar o ESP32-C6:  O ESP32-C6 vem sem  instalado, ent\u00e3o temos que \"flashar\" o firmware.  1- j\u00e1 tenho python instalado entao sigo para a instalacao do esptool: abrir cmd e  pip install esptool  2- agora \u00e9 a parte mais dificil, ligar o esp ao pc usando um cabo USB-C para USB-A ahah  3- Para que este dispositivo seja reconhecido corretamente pelo PC \u00e9 necessario instalar os USB to UART Bridge VCP Drivers . o download pode ser feito em [silicon labs](https://www.silabs.com/developer-tools/usb-to-uart-bridge-vcp-drivers?tab=downloads). Depois de feito o download, temos de extrair os conteudo e procurar um ficheiro chamado ``silabser.inf``, carregar com o bot\u00e3o direito  e instalar. Verificar que agora \u00e9 reconhecido corretamente no device manager como Silicon Labs CP210x USB to UART Bridge (COMx). tomar nota do numero da porta COM, no meu caso \u00e9 o COM3.  4- Agora que temos liga\u00e7\u00e3o podemos limpar a flash do esp de forma a garantir que nao vai haver problemas. para isto corremos `` esptool --port COM3 erase_flash`` se tudo correr bem vemos a mensagem \"Chip erase completed successfully\"  5- Podemos fazer download da vers\u00e3o mais recente para Windows do [**ESP IDF**](https://idf.espressif.com/) para o ESP32-C6 neste [link](https://docs.espressif.com/projects/esp-idf/en/stable/esp32c6/get-started/windows-setup.html). Durante o processo de instalacao selecionei a opcao de ter os shortcuts no desktop para ser mas facil aceder ao ESP-IDF Command Prompt e ao IDE.  6- Depois de instalado para conferir que tudo esta a funcionar corretamente fazer um pequeno teste com hello world: - navegar ate ao exemplo ja incluido de hello world com ``cd %IDF_PATH%\\examples\\get-started\\hello_world`` - dar target nesta board especifica ``idf.py set-target esp32c6`` - dar build no firmware ``idf.py build`` - flashar o firmware para a board ``idf.py -p COM3 flash`` - confirmar que esta a dar print de **Hello World** ao ver o output do serial com ``idf.py -p COM3 monitor``  ### Liga\u00e7\u00f5es como referencia para a ligacoes tenho esta imagem da board que estou a utilizar.  como dito na parte de hardware, o sensair s8 e o plantower pms2.5 comunicam por UART e o sht41 \u00e9 por I2C. ![ssl](images/ESP32-C6.png)  Como descrito na [datasheet](https://api.pim.na.industrial.panasonic.com/file_stream/main/fileversion/244939) do panasonic sn-gcja5, ele pode ser ligado diretamente a minha board porque os terminais SCL e SDA possuem resist\u00eancias de pull up para 3.3V.   ## Troca de Dados  Instalar influxdbv2 download no site, no powershell em administrador navegar ate aos downloads e `` Expand-Archive .\\influxdb2-2.7.11-windows.zip -DestinationPath 'C:\\Program Files\\InfluxData\\' ``, carregar com botao direito no .exe e copiar o path. abrir cmd, colar o path e enter. vai abrir um WebUI da influxdb em localhost:8086. criar conta.  Instalar mosquitto pelo site. abrir cmd navegar ate pasta de instalacao e correr ``mosquitto`` que deve dar inicio ao processo. fazer um teste abrindo 1 cmd e correr ``\"C:\\Program Files\\mosquitto\\mosquitto_sub.exe\" -h 127.0.0.1 -t test/topic`` para subscrever a test/topic e noutro cmd correr ``\"C:\\Program Files\\mosquitto\\mosquitto_pub.exe\" -h 127.0.0.1 -t test/topic -m \"Hello from Mosquitto\"`` como a mensagem hello from mosquitto aparece no primeiro cmd podemos concluir que esta a funcionar a comunicacao mqtt agora temos de conectar o mosquitto com o influxdb atraves do telegraf e mqtt consumer.  Instalar telegraf pelo site, para windows \u00e9 o seguinte:  no powershell em modo administrador   <pre><code>wget https://dl.influxdata.com/telegraf/releases/telegraf-1.34.0_windows_amd64.zip -UseBasicParsing -OutFile telegraf-1.34.0_windows_amd64.zip\n</code></pre>   e no final  <pre><code>Expand-Archive .\\telegraf-1.34.0_windows_amd64.zip -DestinationPath 'C:\\Program Files\\InfluxData\\telegraf'\n</code></pre>     aceder novamente ao webui e criar telegraf configuration file atraves do ui. escolher o bucket Sensores e como plugin library escolher mqtt consumer. adicionar os inputs : ``` [[inputs.mqtt_consumer]]   servers = [\"tcp://127.0.0.1:1883\"]   topics = [     \"sensores/sht41/temperature\",     \"sensores/sht41/humidity\",     \"sensores/gcja5/pm1\",     \"sensores/gcja5/pm2.5\",     \"sensores/gcja5/pm10\",     \"sensores/sensair_s8/co2\"   ]   data_format = \"influx\"   ```  e seguir o resto das instrucoes acerca de adicionar o token.   para testar 2 cmds: 1 deles para monitorizar com  <pre><code>telegraf --config http://localhost:8086/api/v2/telegrafs/0e96aec27fc2a000 --debug\n</code></pre>   e o outro cmd para enviar dados com o mosquitto   <pre><code>mosquitto_pub -h 127.0.0.1 -t sensores/sht41/temperature -m \"temperature,location=office value=25.3\"\n</code></pre>   mensagem de sucesso \"[outputs.influxdb_v2] Wrote batch of 1 metrics in 5.0302ms\"   agora podemos na webui aceder a Data Explorer e carregar em script editor. enviar a query   <pre><code>from(bucket: \"Sensores\")\n  |&gt; range(start: -1h)\n  |&gt; filter(fn: (r) =&gt; r._measurement == \"temperature\" or r._measurement == \"humidity\")\n</code></pre>    podemos assim vizualisar os valores"}]}